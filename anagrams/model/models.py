# Copyright 2011, David Turner <novalis@novalis.org>
#
# This program is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 3 of
# the License, or (props, at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

from datetime import datetime, timedelta
from simplejson import dumps, loads
from pylons import config
from random import shuffle
from sqlobject import *
from sqlobject.versioning import Versioning
from lockfile.linklockfile import LinkLockFile as LockFile
from uuid import uuid4

import time

bag = "AAAAAAAAABBCCDDDDEEEEEEEEEEEEFFGGGHHIIIIIIIIIJKLLLLMMNNNNNNOOOOOOOOPPQRRRRRRSSSSTTTTTTUUUUVVWWXYYZ"

class User(SQLObject):
    class sqlmeta:
        table= 'user_table'

    email = UnicodeCol(alternateID=True, length=32)
    password = UnicodeCol(alternateID=True, length=36) #generated by the system and used for both login and password for STOMP -- this is, actually, a secret

    display_name = UnicodeCol(unique=True, length=20) #the user sets this on login just like isotropic
    #actually, we want to know if users are active and all that
    last_ping = DateTimeCol()
    logged_in = DateTimeCol()
    logged_out = DateTimeCol(default=None)

    game = ForeignKey("Game", default=None)
    word_json = UnicodeCol(length=300, default=None)

    game_state = StringCol(length=10, default=None)

    def to_dict(self):
        return {'display_name' : self.display_name, 'id' : self.id}

    def init_game(self):
        self.game_state="playing"
        self.word_json = "[]"

    def score(self):
        total = 0
        for word in self.words:
            total += len(word) * len(word)
        return total

    def set_word_json(self, value):
        self._SO_set_word_json(value)

    def _get_words(self):
        return loads(self.word_json)

    def remove_word(self, word):
        words = self.words
        words.remove(word)
        self.word_json = dumps(words)
    
    def add_word(self, word):
        words = self.words
        words.append(word)
        self.word_json = dumps(words)
    
    words = property(_get_words)

    def heartbeat(self):
        now = datetime.now()
        self.last_ping = now

    def login(self):
        now = datetime.now()
        self.last_ping = self.logged_in = now
        if self.game and self.game.state != 'playing':
            self.set(game = None, word_json = None, game_state = None)

    def is_logged_in(self):
        now = datetime.now()
        if now - self.last_ping > timedelta(0, 3 * 60, 0):
            self.logged_out = now #three minute timeout
        return self.logged_out is None or self.logged_in > self.logged_out

    @classmethod
    def create(self, email):
        password = str(uuid4())
        now = datetime.now()
        return User(email=email.lower(), password=password, 
                    display_name='none, yet', last_ping = now, 
                    logged_in = now)

    @classmethod
    def createSystemUser(self, password):
        now = datetime.now()
        return User(email='system', password=password, display_name='system', last_ping = now, logged_in = now, logged_out=None, word_json = None)



    @classmethod
    def byEmail(cls, email):
        options = list(cls.select(
            cls.q.email == email.lower()))
        if not options:
            raise SQLObjectNotFound("No user with the email %r" % email)
        return options[0]

    def _set_email(self, value):
        self._SO_set_email(value.lower())

class Game(SQLObject):
    channel = UnicodeCol(length=36) 
    bag = UnicodeCol(length=200)
    center = UnicodeCol(length=200)
    users = MultipleJoin("User", orderBy="display_name")
    state = StringCol(default="invite")
    started = DateTimeCol()
    inviter = ForeignKey("User")
    min_word_len = IntCol(default=4)

    @classmethod
    def create(self, user, min_word_len):
        channel = str(uuid4())
        shuffled = list(bag)
        shuffle(shuffled)
        shuffled = "".join(shuffled)
        now = datetime.now()
        return Game(channel=channel, bag=shuffled, state="invite", started=now,
                    inviter=user, center="", min_word_len = min_word_len)

    def turnup(self):
        if len(self.bag) == 0:
            return None
        new_tile = self.bag[-1]
        self.set(center = self.center + new_tile,
                 bag = self.bag[:-1])
        return new_tile

#Google login stuff -- see user.py for details and attribution
class Association(SQLObject):
    server_url = StringCol(length=2047)
    handle = StringCol(length=255)
    secret = StringCol(length=255)
    issued = IntCol()
    lifetime = IntCol()
    assoc_type = StringCol(length=64)

    @property
    def expiresIn(self):
        result = self.issued - time.time() + self.lifetime
        if result < 0:
            result = 0
        return result


class Nonce(SQLObject):
    server_url = StringCol(length=255)
    timestamp = IntCol()
    salt = StringCol(length=40)

soClasses = [User, Game, Association, Nonce]
